[{"categories":null,"contents":"Google is known for moonshot projects. Often they\u0026rsquo;re just that, without much hope of being brought to fruition in the near future. But Flutter is not one of those: it\u0026rsquo;s here now and it works, wonderfully.\nFlutter was released back in 2017 as a mobile development framework aiming to seamlessly bridge Android and iOS development without taking away any control over the hardware and low-level operating system features from the hands of the software developer, like many other frameworks do. It got lots of attention because Google showed impressive performance results, which are achieved thanks to the use of a low-level rendering engine that doesn\u0026rsquo;t rely on the operating system\u0026rsquo;s native interface elements like similar technologies such as Facebook\u0026rsquo;s React Native do.\nIt also got so much attention because it is being pointed to as the primary way of developing apps for Google\u0026rsquo;s upcoming Fuchsia OS, which is set to replace Google\u0026rsquo;s current operating systems. Developers also loved the top-notch developer tools allowing, among other things, to instantly preview the result of changes to the code without having to compile the app.\nIn addition to being one of the main topics of many conferences dedicated to Dart, the Google-developed programming language used to develop Flutter apps, Flutter has been discussed, presented and advertised for a significant amount of time at Google I/O ever since Flutter\u0026rsquo;s initial release in 2017, and we saw that especially in 2018, when Flutter was really being pushed by Google in anticipation of its 1.0 release in late 2018.\nGoogle I/O 2019 went one step further: experimental support for desktop and web platforms was released, setting forward a vision for a world in which a piece of software doesn\u0026rsquo;t have to be exclusive to one platform: it doesn\u0026rsquo;t matter what platform you need to support if Flutter is powering your app: it doesn’t matter whether they’re phones, tablets, computers, TVs or embedded devices.\nFlutter is not just a big tech preview: it is being used in production today by big companies. Google themselves recently released the official app for Google Stadia, their well-known upcoming game streaming platform. Google also lists companies such as eBay, BMW, AliBaba, Tencent and other companies worth several billion dollars as Flutter users and one of the early adopters of Flutter in early 2018 was the Hamilton musical\u0026rsquo;s app.\nAway from mobile platforms, \u0026ldquo;The New York Times\u0026rdquo; has built some of its web-based digital puzzles in Flutter, that you can see at this link.\nFlutter is reality and it ought to be exciting for everyone: it could be about to bring down the last of the barriers stopping us from forgetting about the underlying interface entirely and think of applications in a way that is only dependent on the choices of the programmer and the requests of the users.\nYou might be wondering what exactly you can expect to be built with it. The answer can be found in more than one way: the first is by taking an inductive approach, looking at what has been built with Flutter.\nThe most obvious example is something like the Hamilton app I mentioned above as the first major app using Flutter because it’s what most people think of when talking about a typical Flutter app. It’s an app that takes up-to-date information from the Internet and shows the information to the user with an unique aesthetic style in multiple layers, mixing everything from news-like sections to trivia quizzes.\nThis is a mix of some of the most common features in mobile apps, but we can highlight Flutter’s flexibility further: it has control over the screen, so games with custom graphics and animations (like the New York Times puzzle linked above) can be built with it, with the same framework that implements easy-to-use classes for all of the components of Material Design and the iOS design language.\nSo Flutter can do anything visually. But we haven\u0026rsquo;t talked about what it can do with the hardware and low-level OS interfaces. To find that out, we are going to take the deductive approach.\nThe short answer is: anything a native app can do, and the reason for that is that Android Flutter apps can run Java/Kotlin or native C++ code just like regular Android SDK apps, Flutter iOS or macOS apps can run native Swift or Objective-C code and Linux apps can run native C++.\nTo any programmer, this simply means that the app has full access to the device\u0026rsquo;s capabilities. An example of that is a project of mine that aims to build a Flutter app that can manage filesystems on Linux by interfacing with Stratis, a Red Hat-developed storage management utility.\nFlutter is even starting to be considered by Linux GUI developers as a potential solution to the inconsistency among different desktop environments, and the people in charge of putting together Linux distributions are taking note and starting to consider putting some effort into making Flutter desktop support even better.\nFlutter\u0026rsquo;s unparalleled flexibility means there will be no duplication of effort in software development teams, increasing their productivity and eliminating any feature gap between versions of the same app developed for different platforms.\nThis is revolutionary and is already taking over market share in the mobile world, all that’s left to see is whether it can adapt and succeed on the other platforms, but with Google behind it and after seeing how many companies are investing heavily into it, it looks like it will change the way software is developed, making it easier for everyone to find high-quality software for any platform, be it a phone, a tablet, a computer or even a completely different kind of device, such as a car’s infotainment system, a smart home device or a smart TV.\n Get a Complete 300-page Introduction to Flutter! I’m so excited about Flutter I wrote a book about it called Programming Flutter with the Pragmatic Bookshelf.\nCheck it Out Here   ","permalink":"https://www.carmine.dev/posts/flutterdesktopweb/","tags":null,"title":"Google's Flutter Framework Could Change Software Forever"},{"categories":null,"contents":" In the previous post we saw how to use Bash to build a simple script that copies some pictures organized into subfolders into a single folder while renaming them and adding some text on them to make it possible for you to know where it was taken based on the folder the pictures were in. I recommend you look at that first because I explain the specific problem being solved, the directory structure and offer a simple solution to the problem. If you can’t be bothered to read that, here’s a summary.\nTL;DR of The Previous Post: The Problem We’re Going to Solve In the previous post I imagined a problem someone could have that could be really easily solved by using computers for what they’re best at: performing repetitive, predictable tasks fast and without requiring the user to do anything while the software does what it’s designed to do.\nThe issue was the organization of pictures from the collection of a tourist who, upon coming back from a trip to Italy, is eager to show to friends and relatives the pictures taken of the many great sights Italy has to offer. To do that, they all need to be in one folder so that they can be shown in sequence easily but they also need to be recognizable both for their filename and for some text shown on them so that the tourist doesn’t necessarily have to remember where each picture was taken.\nWe have a directory tree that looks like this:\nitaly_pics/ ├── Center │ ├── Assisi │ ├── Florence │ ├── Marche │ ├── Pisa │ ├── Rome_Lazio │ └── Siena ├── North │ ├── EmiliaRomagna │ ├── Genoa_CinqueTerre │ ├── Milan_Lombardy │ ├── Trentino │ ├── Turin │ └── Venice └── South ├── Bari_Apulia ├── Basilicata ├── Calabria ├── Campobasso ├── Naples_Campania └── Sicily  With each of the subfolders (Rome_Lazio, Florence, Sicily, etc.) containing one or more pictures.\nThe output will be in another directory, called italy_pics_organized, to be created inside *italy_pics*’s parent directory if it doesn’t exist there already.\nAs I already said, that post outlined the process of writing a solution for this problem using Bash and ImageMagick\u0026rsquo;s convert CLI tool, but this post is here to go beyond that and write something much better with Python.\nWhat the Bash Solution Was Missing: Why Move to Python The Bash solution had multiple issues: it wasn’t portable given that it runs on a specific shell and interpreter that aren’t really great to use if you’re not using an OS that supports it natively (for example, Windows support isn’t great) and that it only works for a very specific directory structure with no files in the directory tree that aren’t images in a subfolder of a subfolder of the current directory.\nSome of you in response to that post mentioned Python as an alternative. As I mentioned in that post, I was already planning to have an article guiding through the creation of a full-blown CLI utility using Python, but we’re probably better off starting with something simpler and more similar to the original script, but that solves some of the issues that are related to the language, such as the ones I described above in addition to being slightly faster and having code that’s a lot easier to read and understand (it’s so nice to use proper programming languages).\nThe main usability improvement will be the ability to specify the input directory and output directory when running the command instead of having them depend on fixed relative paths from the working directory (. and ../italy_pics_organized in our case).\nWhat You Need to Know This post doesn’t suppose you have any experience with Python programming but is not intended to be a comprehensive Python introduction (there is plenty of material on that online, no need to be redundant here). What I will suppose, though, is that you have some basic knowledge of the structure of code written in an object-oriented high-level programming language (selection, iteration, classes, objects, functions, libraries, etc.).\nWhat You Need to Have on Your Computer First of all, let\u0026rsquo;s start by outlining the required tools. The obvious requirement is Python 3 along with the PyPI pip CLI tool installed and accessible from your terminal or command prompt. In addition to that, we\u0026rsquo;re still going to need ImageMagick, but we\u0026rsquo;re not going to use the convert CLI command because we have some nicer interfaces we can work with to build our tool since we\u0026rsquo;re running Python.\nMore specifically, we\u0026rsquo;re going to use the Wand package from PyPI that provides an easy-to-use interface to the ImageMagick libraries.\nRegarding the installation of these tools I recommend you install Python using your distribution\u0026rsquo;s package manager on Linux, using HomeBrew on Mac or by downloading the latest version of Python for Windows and to follow the installation instructions for ImageMagick and Wand on Wand\u0026rsquo;s website.\nAn Introduction to the Wand Python Package After you’ve installed ImageMagick and Wand, we can bypass the usage of the convert which, in a Python script, would require spawning a subprocess and that is something most people don’t really want to do unless strictly necessary: using a library, when it exists, is almost always a better choice.\nWe’re going to use two classes from the wand package: the Image from wand.image and Drawing from wand.drawing, and import them into our code by putting the following at the start of our Python script:\nfrom wand.image import Image from wand.drawing import Drawing  If you have written Python packages in the past you’d know the wand.image and wand.drawing names are due to the internal structure of the package, whereas Image and Drawing are the names of the classes we’re importing.\nThe two classes, when used together, allow us to load images, draw on them, and then save them.\nGetting an Image Object The Image class is meant to be used in a with block like this\nwith Image(filename=filename) as image: # do something with the image, which exists here # as long as you keep indenting the code # the image doesn’t exist here # because the indented block is over  if the path to the file (either relative or absolute) is saved to the filename variable, this will create a variable called image that only exists within the indented block shown in the example above. You can draw on an Image using the Drawing class.\nWe\u0026rsquo;ll be calling methods directly on our image only later, when we save it using image.save.\nThe Drawing Class Before getting into the details of the Drawing class, let\u0026rsquo;s remind ourselves of how we annotated text over images using the convert command-line tool.\nThe command is used like this:\nconvert input.png -fill \u0026quot;textcolor\u0026quot; -pointsize textsize -gravity WhereTheTextWillBe -annotate +offsetHorizontal+offsetVertical \u0026quot;watermark text\u0026quot; output.png  More specifically, we gave the following arguments to that command in the Bash script:\nconvert ./${picture} -fill \u0026quot;white\u0026quot; -pointsize 90 -gravity SouthEast -annotate +30+30 \u0026quot;${watermarktext}\u0026quot; \u0026quot;${saveto}\u0026quot;  and ${variable_name} is how a variable’s value is inserted into a string in Bash.\nThe -fill, -pointsize and -gravity arguments tell convert some of the attributes of the thing we want to draw: what color to fill it with, what size font to use and where to put the new object compared to the original image, while -annotate tells convert what to do: annotate some text over the image offset by 30 pixels horizontally and 30 pixels vertically. the first argument and the last argument are simply the picture we’re drawing the text on and the path where to save the edited image.\nThe way we do that in Python using Wand is by initializing a new Drawing object\ndraw = Drawing()  setting its fill_color property to a string:\ndraw.fill_color = \u0026quot;white\u0026quot;  setting the font_size:\ndraw.font_size = 90  and the annotation’s gravity with a string similar to the one we used for the convert CLI command:\ndraw.gravity = \u0026quot;south_east\u0026quot;  At last, draw the annotation on an Image object:\ndraw.draw(image)  And save the edited image:\nimage.save(filename=f'{saveto}')  Wrapping up, the equivalent to the command we saw above in Python using Wand is\n with Image(filename=picture) as image: draw = Drawing() draw.fill_color = \u0026quot;white\u0026quot; draw.font_size = 90 draw.gravity = \u0026quot;south_east\u0026quot; draw.text(30, 30, text) draw.draw(image) image.save(filename=f'{saveto}')  We will set the value of picture and saveto later.\nHandling Files and Directories in Python The Python standard library contains a module that can be used, among other things, to browse files and directories and to change the current directory (the paths passed to the Image constructor and to Image.save() can also be relative paths).\nThat module can be imported adding\nimport os  below the lines\nfrom wand.image import Image from wand.drawing import Drawing  The most important functions we\u0026rsquo;re going to use from the os module are these three:\nos.chdir, which changes the current working directory to the path you pass to it (which can be relative or absolute, just like the cd shell command; os.listdir, which returns a list of the names of the files and directories in the current directory; os.scandir, which returns a list of files and directories, each of which is an os.DirEntry, which is a type of data that stores, along with the file/directory name, other attributes such as the full path or information on whether it’s a directory or a file.\nIf we had stuck with the Bash script\u0026rsquo;s behavior and only had to look for directories in the starting directory, we could have used\nos.scandir(“.”)  and then only keep its results in a list if they are directories.\nWe now want the user to be able to specify any directory as an argument and look there for pictures given that we considered only looking in the current working directory a limitation of the Bash script.\nWe\u0026rsquo;re simply going to take arguments from the argv interface you might have used in C (or in Python) and use the first argument as the directory from which to take the unedited, structured, pictures and the second one as the output folder where to store the edited pictures.\nCommand-line Arguments and argv When you run a command like cd on a command-line interface, you need to specify an argument: what directory to change the working directory to.\nAs you know, these arguments are specified after the command name in the following way:\ncommandname argument1 argument2 argument3 ...  When writing Python scripts, these arguments are accessible by using the sys.argv list:\nfrom sys import argv # argv[0] = commandname # argv[1] = argument1 # argv[2] = argument2 # argv[3] = argument3 # ...  Regardless of whether you run your script as an executable or by using the python command, argv[0] will always be your script\u0026rsquo;s file name.\nThis means that, if we want the first argument to be where to take the images from, we need to write\nos.scandir(argv[1])  You can check if an os.DirEntry object points to a directory by checking the value returned by its is_dir() method. We’re going to use a list comprehension to do that in a very tidy and compact way:\nareas = [file for file in os.scandir(argv[1]) if file.is_dir()]  For each area:\nfor area in areas:  We’re going to move into the directory corresponding to the area:\nos.chdir(area)  and get a list of the city folders in the current directory:\ncities = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_dir()]  and look for pictures inside each of those directories\nfor city in cities: os.chdir(city) pics = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_file()] # deal with the pictures os.chdir(“..”)  and go back to the parent directory for each area:\nos.chdir(os.pardir)  All in all, until now, we have written the following:\nareas = [file for file in os.scandir(argv[1]) if file.is_dir()] for area in areas: os.chdir(area) cities = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_dir()] for city in cities: os.chdir(city) pics = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_file()] for pic in pics: # deal with each picture os.chdir(\u0026quot;..\u0026quot;) os.chdir(\u0026quot;..\u0026quot;)  Dealing With Each Picture We are going to process each picture by passing all of the needed information to a separate function that will perform all the needed actions with the needed parameters. Before that, we need to focus on one aspect that requires more attention: we are adding to each picture’s filename a progressive number, which is a value we need to keep track of and must be outside of the function that processes each picture.\nHaving that as a global variable is not what we’re going to do because this is a chance to go over OOP in Python and because implementing everything in a class improves code reusability and will be useful in the next post when we build upon the tool we build in this post.\nCreating an ImageProcessor Class First of all, here\u0026rsquo;s how you define a class and a member variable:\nclass ImageProcessor: i = 0  We are going to call the function we built in the previous chapter, which takes the paths from argv, traverses the directory tree and runs another function on each picture process_argv.\nPython methods (if they\u0026rsquo;re not supposed to be static) take the object they are ran on as an argument called self, which is used a lot like this within classes in JavaScript: self.i is the syntax used to access the i member variable, whereas self.process(args) is the syntax used to call the process() method with the args arguments.\nThe final version of the function we built in the previous paragraph, along with a few try-catch blocks to make sure the user input is something we can work with and a call to the yet-to-be-defined process() function and a few lines that deal with the output directory I\u0026rsquo;ll explain after it, is the following:\nclass ImageProcessor: i = 0 def process_argv(self): if len(argv) \u0026lt; 3: print(\u0026quot;Some arguments are missing.\u0026quot;) print(\u0026quot;Usage: picorganizer.py input_directory output_directory\u0026quot;) return areas = [] try: areas = [file for file in os.scandir(argv[1]) if file.is_dir()] if len(areas) == 0: raise Exception(\u0026quot;No subdiretories in input path\u0026quot;) except: print(\u0026quot;The provided input path is not valid\u0026quot;) save_dir = [] try: save_dir = [dir for dir in os.scandir(f\u0026quot;{argv[2]}/..\u0026quot;) if dir.name == os.path.split(argv[2])[1] and dir.is_dir()][0] except: print(\u0026quot;The provided output path doesn't exist or is invalid\u0026quot;) for area in areas: os.chdir(area) cities = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_dir()] for city in cities: os.chdir(city) pics = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_file()] for pic in pics: print(\u0026quot; Pic:\u0026quot; + str(pic)) self.process(area, city, pic, os.path.abspath(save_dir)) os.chdir(os.pardir) os.chdir(os.pardir)  The line\nsave_dir = [dir for dir in os.scandir(f\u0026quot;{argv[2]}/..\u0026quot;) if dir.name == os.path.split(argv[2])[1] and dir.is_dir()][0]]  Scans the second argument (the output directory)s parent directory and, if the entity the user gave us a path to actually exists, we'll assign it to thesave_dirvariable. This is inside atry-catch` block that informs the user of the error and terminates execution if the second argument points to a non-existent directory, given that it would trigger an exception.\nos.path.split(argv[2])[1] is used to access the substring of argv[2] after the last / character. In other words, it is used to access the output directory\u0026rsquo;s name, without the path leading to it.\n\u0026lsquo;f\u0026rdquo;{argv[2]}/..\u0026ldquo;\u0026rsquo; is called an f-string and is how string interpolation is done from Python 3 6 onwards: it is the string made up of the value of argv[2] followed by the /.. characters. For example, if the value of argv[2] were path/to/dir, the value of that f-string would be path/to/dir/.., which is the same as path/to, which is the path to directory where we should be able to find a directory called dir if we list the contents of that directory.\nos.path.abspath(save_dir)) returns the absolute path to the save_dir.\nWriting the process() Method First of all, let\u0026rsquo;s declare the arguments with type annotations, making sure we establish what is needed to make this functiom work:\ndef process(self, area: os.DirEntry, city: os.DirEntry, pic: os.DirEntry, save_dir: str):  We have already seen how to process images, we just need to make it work with these arguments.\nThe first thing to consider is that the process_argv will already change the working directory to the directory in which the image to process is located, so we only need to pass the filename to the Image constructor to get the right image:\nfilename = pic.name  To avoid messing up, before we change the working directory, let\u0026rsquo;s save the absolute path to the current directory to a variable so that we can go back to it after we\u0026rsquo;re done with our processing:\nreturn_dir = os.path.abspath(os.curdir)  The last piece of data we need to extract from the argument is the image\u0026rsquo;s extension, which we can get with os.path.splitext():\n(name, extension) = os.path.splitext(filename)  Here we\u0026rsquo;re unpacking a tuple, which is a pair of values returned by the called function, each of which we can each assign to a variable.\nThe rest of the process function is what we saw at the start of the post when we examined how to use Wand to replace the convert command:\nwith Image(filename=filename) as image: text = f'{city.name}({area.name})' draw = Drawing() draw.fill_color = \u0026quot;white\u0026quot; draw.font_size = 90 draw.gravity = \u0026quot;south_east\u0026quot; draw.text(30, 30, text) draw.draw(image) os.chdir(save_dir) image.save(filename=f'{self.i}-{text}{extension}') self.i=self.i+1 os.chdir(return_dir)  The entire process() function, with a few explanatory comments, ends up being the following:\n def process(self, area: os.DirEntry, city: os.DirEntry, pic: os.DirEntry, save_dir: str): # os.DirEntry.name is the picture's filename filename = pic.name # Store the absolute path of the current directory # so that we can return to it when we're done, # so that the calling function doesn't end up # in a working directory that is not the same # as the one it was in before the call to process() return_dir = os.path.abspath(os.curdir) # os.path.splitext gives us both the file name and # the extension of the picture. We need the extension # because we're going to use it to tell Wand # (and, in turn, ImageMagick) what extension # to give to the image and we want to retain # the original. (name, extension) = os.path.splitext(filename) with Image(filename=filename) as image: text = f'{city.name}({area.name})' draw = Drawing() draw.fill_color = \u0026quot;white\u0026quot; draw.font_size = 90 draw.gravity = \u0026quot;south_east\u0026quot; draw.text(30, 30, text) draw.draw(image) os.chdir(save_dir) image.save(filename=f'{self.i}-{text}{extension}') self.i=self.i+1 os.chdir(return_dir)  Wrapping Up If you liked this post, follow me on Twitter (handle @carminezacc) and check out my Flutter book or my blog at carmine.dev.\nThe entire Python script, including the call to process_argv(), ends up being the following:\nfrom wand.image import Image from wand.drawing import Drawing import os from sys import argv class ImageProcessor: i = 0 def process(self, area: os.DirEntry, city: os.DirEntry, pic: os.DirEntry, save_dir: str): # os.DirEntry.name is the picture's filename filename = pic.name # Store the absolute path of the current directory # so that we can return to it when we're done, # so that the calling function doesn't end up # in a working directory that is not the same # as the one it was in before the call to process() return_dir = os.path.abspath(os.curdir) # os.path.splitext gives us both the file name and # the extension of the picture. We need the extension # because we're going to use it to tell Wand # (and, in turn, ImageMagick) what extension # to give to the image and we want to retain # the original one (name, extension) = os.path.splitext(pic) with Image(filename=filename) as image: text = f'{city.name}({area.name})' draw = Drawing() draw.fill_color = \u0026quot;white\u0026quot; draw.font_size = 90 draw.gravity = \u0026quot;south_east\u0026quot; draw.text(30, 30, text) draw.draw(image) os.chdir(save_dir) image.save(filename=f'{self.i}-{text}{extension}') self.i=self.i+1 os.chdir(return_dir) def process_argv(self): if len(argv) \u0026lt; 3: print(\u0026quot;Some arguments are missing.\u0026quot;) print(\u0026quot;Usage: picorganizer.py input_directory output_directory\u0026quot;) return areas = [] try: areas = [file for file in os.scandir(argv[1]) if file.is_dir()] if len(areas) == 0: raise Exception(\u0026quot;No subdiretories in input path\u0026quot;) except: print(\u0026quot;The provided input path is not valid\u0026quot;) save_dir = [] try: save_dir = [dir for dir in os.scandir(f\u0026quot;{argv[2]}/..\u0026quot;) if dir.name == os.path.split(argv[2])[1] and dir.is_dir()][0] except: print(\u0026quot;The provided output path doesn't exist or is invalid\u0026quot;) for area in areas: os.chdir(area) cities = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_dir()] for city in cities: os.chdir(city) pics = [file for file in os.scandir(\u0026quot;.\u0026quot;) if file.is_file()] for pic in pics: print(\u0026quot; Pic:\u0026quot; + str(pic)) self.process(area, city, pic, os.path.abspath(save_dir)) os.chdir(os.pardir) os.chdir(os.pardir) ImageProcessor().process_argv()  ","permalink":"https://www.carmine.dev/posts/wandpython/","tags":null,"title":"Basic Python Scripting to Automate Everyday Tasks: Add Text to Images Using ImageMagick and Wand"},{"categories":null,"contents":" This article is the first in a series of posts about automating everyday actions. We’ll start with Bash shell scripting, which allows you to write scripts to automate dull, repetitive tasks. You can also find it on my blog.\nThe great advantage of Bash shell scripting compared to writing a full CLI tool to do what we need is that it is very easy to do, especially for those familiar with the Bash shell already, but it is only feasible to build Bash scripts that can be used for a very limited range of applications.\nThe problem to solve Let’s identify a problem anyone can have at some point in life: editing some files according to the folder they’re stored in.\nA relatable, if not too specific, story of someone who needs to learn Bash scripting Let’s say you spend your summer vacation in Italy because you love when the weather is extremely hot, have heard there are beautiful cities, ancient churches, Roman Empire ruins and you want to taste typical Italian food in the place where it all started. However much time you decide to spend, Italy isn’t too big, there are fast trains, and you decide to visit several cities. Just like any tourist, you take pictures everywhere and, by the time you’re back home, you organize your pictures in folders.\nThe current situation At this point you can at least figure out where you were when each picture was taken from the date on which it was taken from the hotel/rail/bus/domestic plane reservations you must have because rental cars with automatic transmissions are very expensive and less than 20% of Americans can drive a manual. You arrange your pictures into subfolders: you have folders for each place you visited and you put those folders in three folders called North, Center and South because it’s nice to be able to know that when you’ll look at the pictures in the future.\nThe problem That in particular is a problem: looking at the pictures will now require you to browse and select pictures in each subfolder manually, and that’s especially painful on some less advanced I/O devices like TV remotes.\nIt would be ideal to be able to take all of those neatly organized pictures you have, put them all in one folder with a watermark telling you where you’ve taken them so it won’t look like you would have been better off just downloading some pictures from the Web when you show them to your friends (or kids) 10 years after you’ve been there.\nDoing that by hand will require another 10 years and your friends or kids will already have visited all of the places you’ve visited fifty times by the time you are done. Fortunately, there is a way to make that quick and easy, and that is by embracing Bash shell scripting.\nSolving the problem Solving this problem requires two different levels of difficulty depending on what operating system you’re running. If you’re running most GNU/Linux distributions or macOS, Bash is your default shell, so it’s already installed and you can go on with the next section without having to install anything else. If you’re running any other Unix or Unix-like operating system that doesn’t install Bash by default, installing Bash is generally very easy and you can find specific instructions online in the very unlikely case you don’t already know how to install a package or port called bash on your OS of choice.\nRunning Bash on Windows If you’re running Windows, you’ll have to install the WSL (Windows Subsystem for Linux) by installing one of the packages available in the Windows Store that include Bash. You just need to open the Windows Store, search for Ubuntu (for example) and install it. When starting for the first time, it will prompt you to enter a username and password you’ll need to remember. The password won’t even be shown to you in the form of asterisks, in case you’re confused by the fact it seems like you’re not actually typing anything in.\nAfter that, you’ll be able to access Bash in any directory on your PC by running the\nbash  command. You can exit the Bash shell by running the\nexit  command.\nMore details about how to use it will be provided in the rest of the article.\nBash scripting: the basics At its simplest, a Bash script is just a list of shell commands separated by newlines or concatenated together using pipes or some of the many script-oriented constructs Bash includes.\nA quick introduction to Bash and the Unix command line This section will be a very quick introduction to the usage of the Bash shell and the Unix command line in general, given that most shells are very similar when it comes to the most basic tasks. There are plenty of books available online that will teach you how to use it, many of which are aimed directly at Linux users, but they also apply to other Unix-like operating systems and to the Windows Subsystem for Linux.\nThe first thing to understand about any command line interface is that it’s like using a file manager: at any point you’re operating in a specific directory, called the working directory. Running the command (by typing it in and then pressing enter)\npwd  will return the current working directory.\nThe directory structure of Unix-like operating systems is a tree that branches out from the single root directory, the path of which is simply the character /. Other directories are chained after that separated by forward slashes. For example, the home directory at the root of the tree is found at path\n/home  and a hypothetical user directory inside that would be at path\n/home/user  Paths can be also expressed as relative paths, based on the current CLI working directory. The current working directory is expressed as ./ and the parent directory (the directory that contains the working directory) is expressed as ../.\nYou can change the working directory using the cd command followed by the path of the directory, expressed either as a relative path or an absolute path. For example, if you want to change the working directory to the parent directory, you’d write\ncd ../  The trailing slash can be omitted and, if you’re moving into a subdirectory you can omit the ./ at the start, making the commands\ncd ./Pictures/italy_pics/  and\ncd Pictures/italy_pics  equivalent.\nFiles can be copied using the cp command, which takes two arguments: the path to the file to be copied and the path where you want the copy to be created, including the file name if you want the copy to have a different name: if you have a file called pic001.png in the italy_pics subdirectory and you want to copy it to the current working directory retaining the original file name, you’d run one of the following three commands (in decreasing order of command length)\ncp italy_pics/pic001.png ./pic001.png cp italy_pics/pic001.png ./ cp italy_pics/pic001.png .  The command to move files is mv and you use it just like cp, except for the fact that it can be used to rename files by trying to move a file into the same directory it came from but with a different file name:\nmv italy_pics/pic001.png italy_pics/pic1.png  While using the interactive shell, you can use the Tab keyboard button to get automatic completion of commands and arguments when there is only one choice or get a list of possible option. This is not relevant for Bash scripting, but will be more relevant in the coming articles.\nRunning a Bash script Bash is an interpreted language and Bash scripts are ran mostly just like .py files.\nTo run a bash script saved in a file called script.sh, open a terminal window in the same directory as the script and run\nbash script.sh  But there is actually a better way: just like with Python scripts, you can add a line at the top of the file, called the shebang line.\nThe shebang line consists of the two characters #! followed by the path to the interpreter to be used to run the script. In the case of bash, it is found at (or symlinked to) /bin/bash in pretty much every environment in which Bash installed, so you can add\n#!/bin/bash  at the very top of your script so that the shell knows what interpreter to run.\nThis is useful because you can make the script executable with\nchmod +x script.sh  and then run it just like any executable with\n./script.sh  ~/bin If it’s a script you think you’ll need to use often, you can either add it to the systemwide binary file paths (where the packages you download are installed) or create a bin folder in your home directory and copy the script there. For example, rename the script file to the command to the name you want to give to the command, for example myfirstscript using mv and then create the ~/bin directory and copy the file there with the following three commands (in an interactive Unix shell or Bash shell on Windows):\nmv script.sh myfirstscript mkdir ~/bin cp myfirstscript ~/bin/  and you can run the script simply by running\nmyfirstscript  from any working directory as long as you’re using the same user account you used to copy the file.\nWriting a basic Bash script Let’s start writing a Bash script by making a script that copies all of our organized pictures into a single directory and renameames them according to the place where they were taken. This is not quite as good as the watermark we wanted, but let’s do one thing at a time\nOpen any text editor and create a file called picorganizer in the ~/bin directory. The first thing you’ll need to add is the shebang line\n#!/bin/bash  Make it executable right away by opening a terminal and running\nchmod +x ~/bin/picorganizer  What our script will actually need to do To solve the problem we have, we need to:\n List the files in the directories we need to copy the files from\n For each file we need to take the following three actions\n Copy the files in the target folder rename the file to a progressive number add a watermark of the place where it was taken   Finding the files we need to copy The example directory tree we\u0026rsquo;ll be working with (that you can get by running the tree command) will be the following\nitaly_pics/ ├── Center │ ├── Assisi │ ├── Florence │ ├── Marche │ ├── Pisa │ ├── Rome_Lazio │ └── Siena ├── North │ ├── EmiliaRomagna │ ├── Genoa_CinqueTerre │ ├── Milan_Lombardy │ ├── Trentino │ ├── Turin │ └── Venice └── South ├── Bari_Apulia ├── Basilicata ├── Calabria ├── Campobasso ├── Naples_Campania └── Sicily  where each city/region name is a directory containing the pictures taken in that place. These are example places in Italy and do not necessarily represent places I would recommend going to, don\u0026rsquo;t judge me for a semi-pseudo-random selection of places.\nTo make the script aware of what we\u0026rsquo;re working with, we need to get a list of files and directories and store them in a Bash variable. Let\u0026rsquo;s start by learning the command to list files and directories.\nIn the Bash interactive shell, we can use the\nls  command to simply list the files and directories contained in the working directory, or you can run it with a path argument, like this:\nls /path/to/dir  to list the files and directories contained in /path/to/dir.\nWe can save the output of the ls command to a variable called list by writing, in our Bash script, the following:\nlist=$(ls)  where $(command) means whatever command prints to standard output. You can then use that variable just by prefixing the variable name with $ or by prefixing it with $ and enclosing the variable name in square brackets: just\nls  is equivalent to\nfiles=$(ls) echo \u0026quot;$files\u0026quot;  and to\nfiles=$(ls) echo \u0026quot;${files}\u0026quot;  This is not actually what we need right now, though: Bash\u0026rsquo;s for in loop is able to iterate over files in the working directory very easily, and we can just nest them and get to the pictures very quickly:\nfor area in *; do for city in ${area}/*; do for picture in ${area}/${city}/*; do # do something with ${area}/${city}/${picture} done done done  We can simply copy them all to another directory renamed to reflect where they were taken by adding the cp command to the innermost for loop:\nmkdir ../italy_pics_organized i=1 for area in *; do for city in ${area}/*; do for picture in ${city}/*; do extension=${picture##*.} cityname=\u0026quot;${city##*/}\u0026quot; cp ${picture} \u0026quot;../italy_pics_organized/${i}-${cityname}(${area}).${extension}\u0026quot; ((i++)) done done done  There are a few things I haven\u0026rsquo;t yet explained and used here. Now I\u0026rsquo;ll explain them.\nFirst of all, Bash doesn\u0026rsquo;t have variable types: every variable is a string and it doesn\u0026rsquo;t implement any mathematical operators or commands directly, so we need to use arithmetic expansion, which supports some specific Shell Arithmetic operators.\nThe ${parameter##word} expression used to get the city name and extension in the following way: it looks inside the parameter for the pattern (word in this notation) we specify after ## (in our case it\u0026rsquo;s *. for the extension and */ for the city name) and only returns the rest of the parameter, deleting the pattern (but keeping it in the original variable). You can find more information about this and the rest of what can be done with parameter expansion using the $ sign here.\nUsing ImageMagick to Add a Watermark We are doing something, and the script isn\u0026rsquo;t going to get much more complicated than that, but we aren\u0026rsquo;t adding a watermark yet. That\u0026rsquo;s because there isn\u0026rsquo;t a built-in tool to do that. No worries, though: the shell is expandable in the easiest way possible: by installing some software that provides a CLI interface.\nThe tool for the job when it comes to image manipulation is ImageMagick, which you can install by following the instructions on its own official download page.\nOn Linux, what I actually recommend you to do is to install the ImageMagick package on Fedora/RHEL/CentOS by running\nsudo dnf install ImageMagick  on Fedora or RHEL/CentOS 8 or by running\nsudo yum install ImageMagick  on RHEL/CentOS 7 or earlier.\nOn Ubuntu, you can install the imagemagick package using APT by running\nsudo apt install imagemagick  When using WSL with Ubuntu installed on top of Windows, you need to follow instructions for installation on Ubuntu while inside the Bash shell interface.\nImageMagick provides, among other things, a command called convert, which can be used, in conjunction with the annotate functionality, to add watermarks to images by running a command that looks like the following:\nconvert input.png -fill \u0026quot;textcolor\u0026quot; -pointsize textsize -gravity WhereTheTextWillBe -annotate +offsetHorizontal+offsetVertical \u0026quot;watermark text\u0026quot; output.png  where you need to replace textcolor with either a color name or an RGB hexadecimal color code (e.g. green or #76ff03), textsize with a number specifying the size of the font (e.g. 10 for a small font, 100 for a big font), WhereTheText will have to be replaced with something along the lines of NorthEast or SouthWest according to where you want the text to be, and paddingHorizontal and paddingVertical are offsets that can be used to move the text around or, more often, away from the edges. input.png and output.png have to be replaced with paths to the input and output pictures.\nFor our example, the command I chose, with ${picture}, ${watermarktext} and ${saveto} being variables, is:\nconvert ./${picture} -fill \u0026quot;white\u0026quot; -pointsize 90 -gravity SouthEast -annotate +30+30 \u0026quot;${watermarktext}\u0026quot; \u0026quot;${saveto}\u0026quot;  So the final script is:\n#!/bin/bash mkdir ../italy_pics_organized i=1 for area in *; do for city in ${area}/*; do for picture in ${city}/*.jpg; do cityname=\u0026quot;${city##*/}\u0026quot; extension=\u0026quot;${picture##*.}\u0026quot; saveto=\u0026quot;../italy_pics_organized/${i}-${cityname}(${area}).${extension}\u0026quot; watermark=\u0026quot;${cityname} (${area})\u0026quot; convert ./${picture} -fill \u0026quot;white\u0026quot; -pointsize 90 -gravity SouthEast -annotate +30+30 \u0026quot;${watermark}\u0026quot; \u0026quot;${saveto}\u0026quot; ((i++)) done done done  After Ben Sinclair in the comments to this post on dev.to noticed that this wouldn\u0026rsquo;t handle spaces in the path properly, I need to point out that you need to change the character used by Bash to separate items to loop through in the for loop by adding two lines at the top like the following:\nIFS=' '  which sets the separator to the newline character (\\n, aka the LF character in character encoding specifications), so that the script ends up being this:\n#!/bin/bash mkdir ../italy_pics_organized i=1 IFS=' ' for area in *; do for city in ${area}/*; do for picture in ${city}/*.jpg; do cityname=\u0026quot;${city##*/}\u0026quot; extension=\u0026quot;${picture##*.}\u0026quot; saveto=\u0026quot;../italy_pics_organized/${i}-${cityname}(${area}).${extension}\u0026quot; watermark=\u0026quot;${cityname} (${area})\u0026quot; convert ./${picture} -fill \u0026quot;white\u0026quot; -pointsize 90 -gravity SouthEast -annotate +30+30 \u0026quot;${watermark}\u0026quot; \u0026quot;${saveto}\u0026quot; ((i++)) done done done  Tips For the Future Here are a few things I didn\u0026rsquo;tell you you might need to know in the future when working with Bash or browsing Bash-related documentation.\nThe Difference Between # and $ Usually, when reading documentation about Unix command line usage (including the sections of my book about cross-platform mobile app development that concern Linux installation or CLI usage, for example) you might find that the commands are prefixed with the character $, like in the following example:\n$ ls -alh  or are prefixed with #, like in the following example:\n# vim /etc/fstab  Those prefixed with $ are meant to be executed as an unprivileged, regular user. Those prefixed with # are meant to be executed by the root account or by using sudo.\nDon\u0026rsquo;t Delete Your Stuff: a (Not So) Funny Anecdote You might want to clean up and use the command\nrm -rf *  if you know the working directory is going to be each of the directories in which you have pictures organized the old way, for example. Only use such a destructive command if you’re 100% sure there is no way for it to get executed in the wrong folder. Make sure to at least turn it into something that only deletes files with the extension you want to delete like this\nrm -rf *.jpg rm -rf *.jpeg  If you’re thinking nobody would be so dumb not to think of it, there is at least one exception in the world. Some years ago I was a bit too confident and wrote a shell script that did some cleaning up afterwards. At some point during the execution of the script, it executed rm -rf * in my home folder. That’s not great.\nI only figured it out when it was halfway through deleting the Documents folder, and it had already deleted the ~/bin folder containing, ironically, most of my commonly used (and harmless) bash scripts (some of which I already was using on some remote servers and that I was able to recover) and itself in the process. I had recent backups of most of the important stuff, so it wasn’t the end of the world for me, but I can’t say it wasn’t annoying.\nThe Bash if Bash has an if clause, I just didn\u0026rsquo;t feel like adding more complication to the script (even though it would have been better for it) by adding functionality that requires its use, its basic syntax is\nif [[ condition ]]; then # do something fi  You can find more information about it online, and online you\u0026rsquo;ll also find a lot more information on Bash than what it\u0026rsquo;s made sense to include in this post.\nStay in touch with me on Twitter @carminezacc or follow my blog to know when the next post (about making a full-featured CLI tool with Python) comes out. Also, if you\u0026rsquo;re interested in mobile development, check out my book on Flutter.\nThanks to Ben Sinclair on dev.to for finding out I had accidentally left spaces around the assignment operator in the two files=$(ls) code snippets, that I should have added ./ before ${picture} so that there\u0026rsquo;s no chance the directory name will be interpreted as an option if it starts with an hyphen and for noticing that you might have spaces in one of the directory names or in the name of one of the picture, which would have broken the script.\n","permalink":"https://www.carmine.dev/posts/bashautomation/","tags":null,"title":"Bash scripting for everyday actions"},{"categories":null,"contents":"\nProgramming Flutter: Native, Cross-Platform Apps the Easy Way is the book I wrote about Flutter with the Pragmatic Bookshelf. You can find it on the official Pragmatic Bookshelf website. Amazon allows you to pre-order the paperback version here, but if you buy the beta eBook you\u0026rsquo;ll also get a discount on the paperback when it comes out, in addition to getting the full final eBook once it comes out, so that might be better, since you can start reading it now (the content is all there already except for the appendices that will come out very soon, it just needs a bit of polish) and then enjoy the full paper book later if you prefer to read books that way.\n","permalink":"https://www.carmine.dev/programmingflutter/","tags":null,"title":"Programming Flutter"},{"categories":null,"contents":" My name is Carmine Zaccagnino and I write some code. In some rare occasions, I also write sentences in natural languages. Even though I am Italian this blog will only contain English when it comes to natural languages. I can make no such guarantees when it comes to programming languages, even though the focus of this blog will certainly be on Flutter. Very similar to this blog, but with some obvious content length differences, is my @carminezacc Twitter account. You can find the articles you can find in this blog and other (older and mostly about Web development) articles on my Medium page, which is all 100% outside the Medium metered paywall. This website doesn\u0026rsquo;t have any analytics so, if you\u0026rsquo;re reading this, I\u0026rsquo;d really like to know what you have to say about this blog or my work in general, and you can let me know by sending me an email at carmine@carminezacc.com or by just sending me a DM on Twitter.\nFlutter Like many of you, I have learned about many web and mobile frameworks over the years and, when it comes to mobile especially, something was clearly missing: there was no simple way to build fast cross-platform mobile apps that also gave me the low-level access of native apps. Flutter is built by Google with support from Apple themselves, gives a simple way to run native Java/Kotlin and Objective-C/Swift code and it supports all of the latest innovation in Android and iOS and produces apps that perform very well.\nLinux, Open-Source, System Administration and DevOps Linux and open-source are topics that I care about deeply, and will certainly find space in this blog at some point. I really enjoy using and developing system administration tools, and I often roll my own Linux server for personal projects even when it\u0026rsquo;s economically disadvantageous when compared with other solutions just for the fun of it (and the control that comes with it).\nMy Relationship with Linux I have been running Linux on my main PC for several years now.\nThe Beginning The first Linux distribution I ever tried running as my main operating system was Mint. Then for a while I was mostly running Ubuntu and Debian both on servers and PCs (about 5-6 years from first approach to vanilla Debian itself to the end of my exclusive love of Debian-based distributions). I was unwilling to leave the apt package manager, the rock-solid Debian stability and the overall setup of Debian system, including the location of logs and configuration files and its behaviour in general: it was what I was used to and I was afraid to leave it.\nUnlocking the Potential That ended when I felt like I needed more bleeding-edge software and heard about openSUSE, zypper and YaST. I felt like I could keep control with some easy to use tools while I got used to the way openSUSE worked in general. For about a year that was enough to keep me using openSUSE (and I still believe zypper and YaST are awesome), then, like many Linux users, I went into a distro-hopping adventure: that transition to openSUSE had completely removed all of the inertia and insecurity that stopped me from trying new distributions.\nHopping Here, Hopping There During that time I tried Arch, which was a bit too different from anything I\u0026rsquo;d tried before to stick, even though I really liked its wiki, and I might come back to it in the future. I also tried Gentoo, but found the need to do so much of the hard work of optimizing compile option myself too time-consuming and not worth the effort. Even if not on bare metal, I also tried some of the BSDs, finding the ports-pkg system overall acceptable. The old school init system and overall setup intrigued me, but didn\u0026rsquo;t really feel like something I\u0026rsquo;d want to use everyday.\nSettling Down What I ended up settling on for my desktop distribution is Fedora, starting from when version 25 had just come out, mostly because I was intrigued by Wayland\u0026rsquo;s promise of burning down all of the limitations of the anachronism X11 had become and Fedora\u0026rsquo;s very unique hybrid feel between rolling and fixed releases and frequent kernel updates. It was also partially because I had tried CentOS earlier and had started deploying that on my servers instead of Debian. I love Fedora now, and feel like Red Hat is more trustworthy and open than some other companies that are heavily invested into open-source and Linux: they sponsor CentOS, which had been for years pretty much the legal pirate version of RHEL, and aren\u0026rsquo;t doing anything to stop anyone from using, for free, the same operating system they are selling to companies for a significant amount of money. Obviously buying RHEL is mostly about receiving support, but letting anybody run the same software for free is still commendable.\nContributing Everyone says that contributing to open source is a great thing to do for developers of all levels of expertise, and it\u0026rsquo;s really true: if you\u0026rsquo;re a beginner, it\u0026rsquo;s an easy way to get started writing code that does something useful without having to think about what it can be: it already exists, you just need to improve it. For everyone else, it\u0026rsquo;s a nice and relaxing way to code on someone else\u0026rsquo;s terms and to break the boredom that is usually associated with working on the same thing over and over again (for me, at least): don\u0026rsquo;t change jobs, change your hobbies.\nThe first thing to do is to find projects that interest you.\nOne thing peaked my interest from Red Hat lately: their Stratis storage management tool, which promises to give an easy way to manage a machine\u0026rsquo;s storage, without having to worry about RAID levels or scaling issues: you just add or remove disks to be used for data or redundancy in a pool and mount the virtual device you created. The small contributions I made to its CLI tool are among the very few open-source contributions documented on my main GitHub profile, given that I contributed some projects that bypass GitHub and to some with other e-mail addresses.\nThe Web Web development is also something that will be discussed in this blog as there really is a lot to say about it, both on both the front-end and back-end sides of things, with a focus on back-end frameworks.\nI used to write a lot more about Web development, especially back-end frameworks, and you can find some of my (worst) stuff on my Medium. Maybe there will be some Web development stuff over here too. As always, you can send me an e-mail and let me know whether or not you\u0026rsquo;d appreciate that, there\u0026rsquo;s no point in writing what I\u0026rsquo;d want to read if noone else cares about it.\n","permalink":"https://www.carmine.dev/aboutme/","tags":null,"title":"About Me"},{"categories":null,"contents":" My name is Carmine Zaccagnino and I write some code. In some rare occasions, I also write sentences in natural languages. Even though I am Italian this blog will only contain English when it comes to natural languages. I can make no such guarantees when it comes to programming languages, even though the focus of this blog will certainly be on Flutter. Very similar to this blog, but with some obvious content length differences, is my @carminezacc Twitter account. You can find the articles you can find in this blog and other (older and mostly about Web development) articles on my Medium page, which is all 100% outside the Medium metered paywall. This website doesn\u0026rsquo;t have any analytics so, if you\u0026rsquo;re reading this, I\u0026rsquo;d really like to know what you have to say about this blog or my work in general, and you can let me know by sending me an email at carmine@carminezacc.com or by just sending me a DM on Twitter.\nFlutter Like many of you, I have learned about many web and mobile frameworks over the years and, when it comes to mobile especially, something was clearly missing: there was no simple way to build fast cross-platform mobile apps that also gave me the low-level access of native apps. Flutter is built by Google with support from Apple themselves, gives a simple way to run native Java/Kotlin and Objective-C/Swift code and it supports all of the latest innovation in Android and iOS and produces apps that perform very well.\nLinux, Open-Source, System Administration and DevOps Linux and open-source are topics that I care about deeply, and will certainly find space in this blog at some point. I really enjoy using and developing system administration tools, and I often roll my own Linux server for personal projects even when it\u0026rsquo;s economically disadvantageous when compared with other solutions just for the fun of it (and the control that comes with it).\nMy Relationship with Linux I have been running Linux on my main PC for several years now.\nThe Beginning The first Linux distribution I ever tried running as my main operating system was Mint. Then for a while I was mostly running Ubuntu and Debian both on servers and PCs (about 5-6 years from first approach to vanilla Debian itself to the end of my exclusive love of Debian-based distributions). I was unwilling to leave the apt package manager, the rock-solid Debian stability and the overall setup of Debian system, including the location of logs and configuration files and its behaviour in general: it was what I was used to and I was afraid to leave it.\nUnlocking the Potential That ended when I felt like I needed more bleeding-edge software and heard about openSUSE, zypper and YaST. I felt like I could keep control with some easy to use tools while I got used to the way openSUSE worked in general. For about a year that was enough to keep me using openSUSE (and I still believe zypper and YaST are awesome), then, like many Linux users, I went into a distro-hopping adventure: that transition to openSUSE had completely removed all of the inertia and insecurity that stopped me from trying new distributions.\nHopping Here, Hopping There During that time I tried Arch, which was a bit too different from anything I\u0026rsquo;d tried before to stick, even though I really liked its wiki, and I might come back to it in the future. I also tried Gentoo, but found the need to do so much of the hard work of optimizing compile option myself too time-consuming and not worth the effort. Even if not on bare metal, I also tried some of the BSDs, finding the ports-pkg system overall acceptable. The old school init system and overall setup intrigued me, but didn\u0026rsquo;t really feel like something I\u0026rsquo;d want to use everyday.\nSettling Down What I ended up settling on for my desktop distribution is Fedora, starting from when version 25 had just come out, mostly because I was intrigued by Wayland\u0026rsquo;s promise of burning down all of the limitations of the anachronism X11 had become and Fedora\u0026rsquo;s very unique hybrid feel between rolling and fixed releases and frequent kernel updates. It was also partially because I had tried CentOS earlier and had started deploying that on my servers instead of Debian. I love Fedora now, and feel like Red Hat is more trustworthy and open than some other companies that are heavily invested into open-source and Linux: they sponsor CentOS, which had been for years pretty much the legal pirate version of RHEL, and aren\u0026rsquo;t doing anything to stop anyone from using, for free, the same operating system they are selling to companies for a significant amount of money. Obviously buying RHEL is mostly about receiving support, but letting anybody run the same software for free is still commendable.\nContributing Everyone says that contributing to open source is a great thing to do for developers of all levels of expertise, and it\u0026rsquo;s really true: if you\u0026rsquo;re a beginner, it\u0026rsquo;s an easy way to get started writing code that does something useful without having to think about what it can be: it already exists, you just need to improve it. For everyone else, it\u0026rsquo;s a nice and relaxing way to code on someone else\u0026rsquo;s terms and to break the boredom that is usually associated with working on the same thing over and over again (for me, at least): don\u0026rsquo;t change jobs, change your hobbies.\nThe first thing to do is to find projects that interest you.\nOne thing peaked my interest from Red Hat lately: their Stratis storage management tool, which promises to give an easy way to manage a machine\u0026rsquo;s storage, without having to worry about RAID levels or scaling issues: you just add or remove disks to be used for data or redundancy in a pool and mount the virtual device you created. The small contributions I made to its CLI tool are among the very few open-source contributions documented on my main GitHub profile, given that I contributed some projects that bypass GitHub and to some with other e-mail addresses.\nThe Web Web development is also something that will be discussed in this blog as there really is a lot to say about it, both on both the front-end and back-end sides of things, with a focus on back-end frameworks.\nI used to write a lot more about Web development, especially back-end frameworks, and you can find some of my (worst) stuff on my Medium. Maybe there will be some Web development stuff over here too. As always, you can send me an e-mail and let me know whether or not you\u0026rsquo;d appreciate that, there\u0026rsquo;s no point in writing what I\u0026rsquo;d want to read if noone else cares about it.\n","permalink":"https://www.carmine.dev/author/carmine-zaccagnino/","tags":null,"title":"Carmine Zaccagnino"}]